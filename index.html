<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8" />
  <title>GPX 轨迹可视化 (拖放加载) - 带方向箭头</title>
  <meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no" />
  <link href="https://unpkg.com/maplibre-gl@4.1.0/dist/maplibre-gl.css" rel="stylesheet" />
  <style>
    body {
      margin: 0;
      padding: 0;
    }

    #map {
      position: absolute;
      top: 0;
      bottom: 0;
      width: 100%;
      background-color: #f0f0f0;
      /* Default background for map area */
    }

    .controls {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(255, 255, 255, 0.9);
      /* Slightly more opaque */
      padding: 10px 20px;
      border-radius: 8px;
      /* Softer corners */
      z-index: 1;
      display: flex;
      align-items: center;
      gap: 15px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      /* Enhanced shadow */
    }

    .controls label {
      font-family: sans-serif;
      font-size: 14px;
    }

    #timeslider {
      width: 300px;
    }

    #timestamp-display {
      font-family: monospace;
      font-size: 13px;
      min-width: 180px;
      /* 保证足够宽度显示时间 */
      padding: 5px;
      background-color: #f8f9fa;
      border-radius: 4px;
    }

    /* Style for drag-over effect */
    #map.dragover {
      border: 3px dashed #007bff;
      box-shadow: inset 0 0 30px rgba(0, 123, 255, 0.3);
    }

    .drop-prompt {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background-color: rgba(255, 255, 255, 0.95);
      padding: 25px 30px;
      border-radius: 10px;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      /* Modern font */
      font-size: 1.3em;
      color: #333;
      text-align: center;
      z-index: 10;
      pointer-events: auto;
      /* 允许点击交互 */
      display: none;
      /* Hidden by default */
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
      cursor: pointer;
      /* 鼠标悬停时显示指针 */
      transition: background-color 0.2s, transform 0.1s;
      /* 平滑过渡效果 */
    }

    .drop-prompt:hover {
      background-color: rgba(255, 255, 255, 1);
      transform: translate(-50%, -50%) scale(1.02);
      /* 轻微放大效果 */
    }

    .drop-prompt:active {
      transform: translate(-50%, -50%) scale(0.98);
      /* 点击时缩小效果 */
    }

    /* Show prompt when no track is loaded */
    #map.no-track .drop-prompt {
      display: block;
    }

    /* 隐藏文件输入框 */
    #file-input {
      display: none;
    }
  </style>
</head>

<body>

  <div id="map">
    <div class="drop-prompt" id="drop-prompt-message">请拖放 GPX 文件到地图区域<br>或点击此处选择文件</div>
  </div>
  <div class="controls">
    <label for="timeslider">轨迹进度:</label>
    <input type="range" id="timeslider" min="0" value="0" step="1" disabled />
    <div id="timestamp-display">未加载数据</div>
  </div>
  <input type="file" id="file-input" accept=".gpx" />

  <script src="https://unpkg.com/maplibre-gl@4.1.0/dist/maplibre-gl.js"></script>
  <script>
    let map;
    let currentPoints = [];
    let currentFullTrackGeoJSON = { type: 'Feature', geometry: { type: 'LineString', coordinates: [] }, properties: {} };

    const slider = document.getElementById('timeslider');
    const timestampDisplay = document.getElementById('timestamp-display');
    const mapContainer = document.getElementById('map');
    const dropPromptMessage = document.getElementById('drop-prompt-message');
    const fileInput = document.getElementById('file-input');

    dropPromptMessage.addEventListener('click', () => fileInput.click());
    fileInput.addEventListener('change', (event) => {
      if (event.target.files && event.target.files.length > 0) {
        processSelectedFile(event.target.files[0]);
      }
    });

    function processSelectedFile(file) {
      if (file.name.toLowerCase().endsWith('.gpx')) {
        dropPromptMessage.textContent = "正在处理 GPX 文件...";
        const reader = new FileReader();
        reader.onload = (e) => {
          try {
            const gpxString = e.target.result;
            const newRawData = parseGPXToRawTrackData(gpxString);
            if (newRawData !== null) {
              loadTrackDataOnMap(newRawData);
            } else {
              timestampDisplay.textContent = "GPX 解析失败";
              slider.disabled = true;
              mapContainer.classList.add('no-track');
              dropPromptMessage.textContent = "GPX 解析失败，请检查文件并重试\n或点击此处选择另一个文件";
            }
          } catch (error) {
            console.error("处理 GPX 文件时出错:", error);
            alert("处理 GPX 文件时发生意外错误: " + error.message);
            timestampDisplay.textContent = "GPX 加载异常";
            slider.disabled = true;
            mapContainer.classList.add('no-track');
            dropPromptMessage.textContent = "GPX 加载异常，请重试\n或点击此处选择另一个文件";
          }
        };
        reader.onerror = (e) => {
          console.error("读取文件失败:", e);
          alert("读取文件失败。请检查浏览器权限或文件本身。");
          timestampDisplay.textContent = "文件读取错误";
          slider.disabled = true;
          mapContainer.classList.add('no-track');
          dropPromptMessage.textContent = "文件读取错误，请重试\n或点击此处选择另一个文件";
        };
        reader.readAsText(file);
      } else {
        alert("请选择一个 .gpx 文件。");
        dropPromptMessage.textContent = "非 GPX 文件，请选择或拖放 .gpx 文件";
        setTimeout(() => {
          if (currentPoints.length === 0) dropPromptMessage.textContent = "请拖放 GPX 文件到地图区域\n或点击此处选择文件";
        }, 2000);
      }
      fileInput.value = '';
    }

    function processTrackData(rawData) {
      if (!rawData || rawData.length === 0) {
        return {
          points: [],
          fullTrackGeoJSON: { type: 'Feature', geometry: { type: 'LineString', coordinates: [] }, properties: {} }
        };
      }
      const sortedRawData = rawData.sort((a, b) => a.timestamp - b.timestamp);
      const points = sortedRawData.map(p => ({
        longitude: p.longitude_scaled_1e5 / 1e5,
        latitude: p.latitude_scaled_1e5 / 1e5,
        altitude: p.altitude_m_scaled_1e1 / 1e1,
        timestamp: p.timestamp
      }));
      const coordinates = points.map(p => [p.longitude, p.latitude, p.altitude]);
      return {
        points: points,
        fullTrackGeoJSON: {
          type: 'Feature',
          geometry: { type: 'LineString', coordinates: coordinates },
          properties: {}
        }
      };
    }

    function parseGPXToRawTrackData(gpxString) {
      const parser = new DOMParser();
      const xmlDoc = parser.parseFromString(gpxString, "text/xml");
      const newRawData = [];
      const parseError = xmlDoc.getElementsByTagName("parsererror");
      if (parseError.length > 0) {
        console.error("GPX parsing error:", parseError[0].textContent);
        alert("GPX 文件解析失败。请检查文件格式。\n错误详情: " + parseError[0].textContent);
        return null;
      }
      const trkpts = xmlDoc.querySelectorAll('trkpt');
      if (trkpts.length === 0) {
        console.warn("GPX 文件中未找到 <trkpt> 元素。");
        alert("GPX 文件中未找到有效的轨迹点 (<trkpt>)。");
        return [];
      }
      trkpts.forEach((trkpt, index) => {
        const latAttr = trkpt.getAttribute('lat');
        const lonAttr = trkpt.getAttribute('lon');
        if (!latAttr || !lonAttr) {
          console.warn(`Trackpoint ${index + 1} 缺少经纬度属性，将被跳过。`);
          return;
        }
        const lat = parseFloat(latAttr);
        const lon = parseFloat(lonAttr);
        let ele = 0;
        const eleTag = trkpt.querySelector('ele');
        if (eleTag && eleTag.textContent) ele = parseFloat(eleTag.textContent);
        let time = null;
        const timeTag = trkpt.querySelector('time');
        if (timeTag && timeTag.textContent) {
          time = Math.floor(new Date(timeTag.textContent).getTime() / 1000);
        } else {
          console.warn(`Trackpoint ${index + 1} (Lat: ${lat}, Lon: ${lon}) 缺少时间信息，将被跳过。`);
          return;
        }
        if (!isNaN(lat) && !isNaN(lon) && time !== null && !isNaN(time)) {
          newRawData.push({
            timestamp: time,
            latitude_scaled_1e5: Math.round(lat * 1e5),
            longitude_scaled_1e5: Math.round(lon * 1e5),
            altitude_m_scaled_1e1: Math.round(ele * 1e1)
          });
        } else {
          console.warn(`跳过无效的轨迹点数据: Lat=${lat}, Lon=${lon}, Time=${time}, Ele=${ele}`);
        }
      });
      if (newRawData.length === 0 && trkpts.length > 0) {
        alert("GPX 文件中的轨迹点均无效或缺少必要信息 (有效的经纬度、时间)。");
      }
      return newRawData;
    }

    function updateMapForIndex(index) {
      if (!map.loaded() || !map.getSource('current-point') || !map.getSource('travelled-track')) {
        console.warn("Map or sources not ready for updateMapForIndex");
        return;
      }
      if (!currentPoints || currentPoints.length === 0 || index < 0 || index >= currentPoints.length) {
        if (currentPoints && currentPoints.length === 0) {
          timestampDisplay.textContent = "无轨迹数据";
          map.getSource('current-point').setData({ type: 'FeatureCollection', features: [] });
          map.getSource('travelled-track').setData({ type: 'Feature', geometry: { type: 'LineString', coordinates: [] }, properties: {} });
        }
        return;
      }
      const currentPointData = currentPoints[index];
      map.getSource('current-point').setData({
        type: 'Feature',
        geometry: { type: 'Point', coordinates: [currentPointData.longitude, currentPointData.latitude] },
        properties: { timestamp: currentPointData.timestamp, altitude: currentPointData.altitude }
      });
      const travelledCoordinates = currentPoints.slice(0, index + 1).map(p => [p.longitude, p.latitude, p.altitude]);
      map.getSource('travelled-track').setData({
        type: 'Feature',
        geometry: { type: 'LineString', coordinates: travelledCoordinates },
        properties: {}
      });
      const date = new Date(currentPointData.timestamp * 1000);
      timestampDisplay.textContent = `${date.toLocaleString()} (海拔: ${currentPointData.altitude.toFixed(1)}m)`;
    }

    // NEW: Function to calculate bearing between two points
    function calculateBearing(lat1, lon1, lat2, lon2) {
      const toRadians = Math.PI / 180;
      const toDegrees = 180 / Math.PI;

      const y = Math.sin((lon2 - lon1) * toRadians) * Math.cos(lat2 * toRadians);
      const x = Math.cos(lat1 * toRadians) * Math.sin(lat2 * toRadians) -
        Math.sin(lat1 * toRadians) * Math.cos(lat2 * toRadians) * Math.cos((lon2 - lon1) * toRadians);
      let brng = Math.atan2(y, x) * toDegrees;
      brng = (brng + 360) % 360; // Normalize to 0-360
      return brng;
    }

    // Helper function to calculate distance between two lat/lon points (Haversine formula)
    function calculateDistance(lat1, lon1, lat2, lon2) {
      const R = 6371e3; // Earth radius in meters
      const phi1 = lat1 * Math.PI / 180;
      const phi2 = lat2 * Math.PI / 180;
      const deltaPhi = (lat2 - lat1) * Math.PI / 180;
      const deltaLambda = (lon2 - lon1) * Math.PI / 180;

      const a = Math.sin(deltaPhi / 2) * Math.sin(deltaPhi / 2) +
        Math.cos(phi1) * Math.cos(phi2) *
        Math.sin(deltaLambda / 2) * Math.sin(deltaLambda / 2);
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

      return R * c; // Distance in meters
    }

    // MODIFIED: Function to generate GeoJSON features for arrows, now based on distance
    function generateArrowFeatures(trackPoints) {
      const features = [];
      if (!trackPoints || trackPoints.length < 2) {
        return { type: 'FeatureCollection', features: features };
      }

      const arrowIntervalMeters = 250; // Desired distance between arrows in meters
      let distanceSinceLastArrow = 0;

      // Add first arrow at the start of the track.
      // Bearing from the first point to the second point.
      // calculateBearing will return 0 if p0 and p1 are identical.
      let bearing = calculateBearing(trackPoints[0].latitude, trackPoints[0].longitude, trackPoints[1].latitude, trackPoints[1].longitude);
      features.push({
        type: 'Feature',
        geometry: {
          type: 'Point',
          coordinates: [trackPoints[0].longitude, trackPoints[0].latitude]
        },
        properties: {
          bearing: bearing
        }
      });

      // Iterate through the track points starting from the second point
      for (let i = 1; i < trackPoints.length; i++) {
        const p1 = trackPoints[i - 1];
        const p2 = trackPoints[i];
        if (p1.longitude === p2.longitude && p1.latitude === p2.latitude) continue;
        const segmentDistance = calculateDistance(p1.latitude, p1.longitude, p2.latitude, p2.longitude);
        const totalDistance = distanceSinceLastArrow + segmentDistance;
        if (totalDistance >= arrowIntervalMeters) {
          const arrowCount = Math.floor(totalDistance / arrowIntervalMeters);
          for (let j = 1; j <= arrowCount; j++) {
            const d = arrowIntervalMeters * j - distanceSinceLastArrow;
            const t = d / segmentDistance;
            const lat = p1.latitude + (p2.latitude - p1.latitude) * t;
            const lon = p1.longitude + (p2.longitude - p1.longitude) * t;
            const bearing = calculateBearing(p1.latitude, p1.longitude, p2.latitude, p2.longitude);
            features.push({
              type: 'Feature',
              geometry: { type: 'Point', coordinates: [lon, lat] },
              properties: { bearing }
            });
          }
          distanceSinceLastArrow = totalDistance % arrowIntervalMeters;
        } else {
          distanceSinceLastArrow = totalDistance;
        }
      }

      return { type: 'FeatureCollection', features: features };
    }

    function loadTrackDataOnMap(newRawTrackData) {
      const processed = processTrackData(newRawTrackData);
      currentPoints = processed.points;
      currentFullTrackGeoJSON = processed.fullTrackGeoJSON;

      if (currentPoints.length === 0) {
        timestampDisplay.textContent = "GPX 文件无有效轨迹数据";
        slider.disabled = true;
        slider.value = 0;
        slider.max = 0;
        mapContainer.classList.add('no-track');
        dropPromptMessage.textContent = "GPX 无有效数据或解析失败，请重试\n或点击此处选择另一个文件";
        if (map.getSource('full-track')) {
          map.getSource('full-track').setData({ type: 'Feature', geometry: { type: 'LineString', coordinates: [] }, properties: {} });
        }
        // NEW: Clear arrows if no track data
        if (map.getSource('arrow-points')) {
          map.getSource('arrow-points').setData({ type: 'FeatureCollection', features: [] });
        }
        updateMapForIndex(0);
        return;
      }

      mapContainer.classList.remove('no-track');
      slider.max = currentPoints.length - 1;
      slider.value = 0;
      slider.disabled = false;

      map.getSource('full-track').setData(currentFullTrackGeoJSON);
      updateMapForIndex(0);

      // NEW: Generate and display arrows for the full track
      if (map.getSource('arrow-points') && map.style.getImage('arrow-icon')) { // Check if arrow icon is loaded
        const arrowFeatures = generateArrowFeatures(currentPoints);
        map.getSource('arrow-points').setData(arrowFeatures);
      } else if (map.getSource('arrow-points')) {
        // Icon might not be loaded yet if this is the first load. Add a small delay or re-check.
        // For simplicity, we assume it will be loaded. A more robust solution might queue this update.
        console.warn("Arrow icon not yet loaded, arrows might not appear immediately.");
        // Retry setting data after a short delay for image to load
        setTimeout(() => {
          if (map.getSource('arrow-points') && map.style.getImage('arrow-icon')) {
            const arrowFeatures = generateArrowFeatures(currentPoints);
            map.getSource('arrow-points').setData(arrowFeatures);
          }
        }, 500);

      }


      if (currentFullTrackGeoJSON.geometry.coordinates.length > 1) {
        const bounds = new maplibregl.LngLatBounds();
        currentFullTrackGeoJSON.geometry.coordinates.forEach(coord => {
          bounds.extend(coord.slice(0, 2));
        });
        map.fitBounds(bounds, { padding: 60 });
      }
    }

    function handleFileDrop(event) {
      event.preventDefault();
      event.stopPropagation();
      mapContainer.classList.remove('dragover');
      dropPromptMessage.textContent = "正在处理 GPX 文件...";
      if (event.dataTransfer.files && event.dataTransfer.files.length > 0) {
        processSelectedFile(event.dataTransfer.files[0]);
      } else {
        if (currentPoints.length === 0) dropPromptMessage.textContent = "请拖放 GPX 文件到地图区域\n或点击此处选择文件";
      }
    }

    function handleDragOver(event) {
      event.preventDefault();
      event.stopPropagation();
      mapContainer.classList.add('dragover');
      dropPromptMessage.textContent = "松开以加载 GPX 文件";
    }

    function handleDragLeave(event) {
      event.preventDefault();
      event.stopPropagation();
      mapContainer.classList.remove('dragover');
      if (currentPoints.length === 0) {
        dropPromptMessage.textContent = "请拖放 GPX 文件到地图区域\n或点击此处选择文件";
      }
    }

    map = new maplibregl.Map({
      container: 'map',
      style: 'https://tiles.openfreemap.org/styles/liberty',
      center: [139.767, 35.681],
      zoom: 5
    });

    map.on('load', () => {
      mapContainer.classList.add('no-track');

      map.addSource('full-track', {
        type: 'geojson',
        data: currentFullTrackGeoJSON
      });
      map.addLayer({
        id: 'full-track-line',
        type: 'line',
        source: 'full-track',
        layout: { 'line-join': 'round', 'line-cap': 'round' },
        paint: { 'line-color': '#007bff', 'line-width': 5, 'line-opacity': 0.8 }
      });

      // Add source and layer for the highlighted segment
      map.addSource('highlighted-segment', {
        type: 'geojson',
        data: { type: 'Feature', geometry: { type: 'LineString', coordinates: [] }, properties: {} }
      });
      map.addLayer({
        id: 'highlighted-segment-line',
        type: 'line',
        source: 'highlighted-segment',
        layout: { 'line-join': 'round', 'line-cap': 'round' },
        paint: {
          'line-color': '#FFD700', // Gold color for highlight
          'line-width': 7,         // Slightly wider
          'line-opacity': 0.85
        }
      }); // This layer will be on top of 'full-track-line' by default

      // NEW: Add SVG arrow image to map's style
      const arrowUpSvgString = `<svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 12 12"><polygon points="6,0 12,9 0,9" fill="currentColor"/></svg>`;


      const img = new Image(16, 16); // Should match SVG width/height for consistency, or let browser decide.
      img.onload = () => {
        map.addImage('arrow-icon', img, { sdf: true }); // sdf: true allows recoloring

        // NEW: Add source for arrow points (initially empty)
        map.addSource('arrow-points', {
          type: 'geojson',
          data: { type: 'FeatureCollection', features: [] }
        });

        // NEW: Add layer for arrows, below the travelled track and current point for clarity
        map.addLayer({
          id: 'gpx-arrows',
          type: 'symbol',
          source: 'arrow-points',
          layout: {
            'icon-image': 'arrow-icon',
            'icon-size': 0.7, // Adjust size as needed
            'icon-rotate': ['get', 'bearing'],
            'icon-rotation-alignment': 'map',
            'icon-allow-overlap': true,
            'icon-ignore-placement': true // Important to show all arrows
          },
          paint: {
            'icon-color': '#003399', // Dark blue, or choose another color
            'icon-opacity': 0.85
          }
        }, 'travelled-track-line'); // Place arrows below travelled track, adjust if needed
      };
      img.onerror = (e) => {
        console.error("Failed to load arrow SVG for map icon.", e);
        alert("无法加载箭头图标，轨迹方向将不显示。");
      };
      // Using a triangle pointing "up" (in its local SVG coordinate space, Y decreases upwards).
      // For a map icon that should point "north" at 0 degrees rotation, this means pointing to top of SVG.
      img.src = 'data:image/svg+xml;base64,' + btoa(arrowUpSvgString);


      map.addSource('travelled-track', {
        type: 'geojson',
        data: { type: 'Feature', geometry: { type: 'LineString', coordinates: [] }, properties: {} }
      });
      map.addLayer({
        id: 'travelled-track-line',
        type: 'line',
        source: 'travelled-track',
        layout: { 'line-join': 'round', 'line-cap': 'round' },
        paint: { 'line-color': '#28a745', 'line-width': 6, 'line-opacity': 0.9 }
      });

      map.addSource('current-point', {
        type: 'geojson',
        data: { type: 'FeatureCollection', features: [] }
      });
      map.addLayer({
        id: 'current-point-marker',
        type: 'circle',
        source: 'current-point',
        paint: {
          'circle-radius': 8, 'circle-color': '#dc3545',
          'circle-stroke-width': 2, 'circle-stroke-color': '#ffffff'
        }
      });

      mapContainer.addEventListener('dragover', handleDragOver);
      mapContainer.addEventListener('dragleave', handleDragLeave);
      mapContainer.addEventListener('drop', handleFileDrop);

      timestampDisplay.textContent = "请拖放 GPX 文件";
      slider.disabled = true;
      slider.value = 0;
      slider.max = 0;

      // NEW: Popup for track segment information
      let trackPopup = new maplibregl.Popup({
        closeButton: false,
        closeOnClick: false,
        offset: 15 // Offset the popup slightly from the cursor
      });

      map.on('mousemove', 'full-track-line', function (e) {
        if (!currentPoints || currentPoints.length < 2) {
          if (trackPopup.isOpen()) trackPopup.remove();
          map.getCanvas().style.cursor = '';
          return;
        }
        map.getCanvas().style.cursor = 'pointer';

        const mouseLngLat = e.lngLat;
        let closestSegment = null;
        let minDistanceSqToMidpoint = Infinity; // Using squared distance to avoid sqrt

        for (let i = 0; i < currentPoints.length - 1; i++) {
          const p1 = currentPoints[i];
          const p2 = currentPoints[i + 1];

          // Ensure p1 and p2 are valid points with longitude and latitude
          if (!p1 || !p2 || typeof p1.longitude !== 'number' || typeof p1.latitude !== 'number' ||
            typeof p2.longitude !== 'number' || typeof p2.latitude !== 'number') {
            console.warn('Skipping invalid segment due to missing coordinates:', p1, p2);
            continue;
          }

          const midLng = (p1.longitude + p2.longitude) / 2;
          const midLat = (p1.latitude + p2.latitude) / 2;

          // Approximate distance squared (faster than sqrt) from mouse to segment midpoint
          const distLat = midLat - mouseLngLat.lat;
          const distLng = midLng - mouseLngLat.lng;
          const distanceSq = distLat * distLat + distLng * distLng;

          if (distanceSq < minDistanceSqToMidpoint) {
            minDistanceSqToMidpoint = distanceSq;
            closestSegment = { p1, p2, index: i };
          }
        }

        if (closestSegment) {
          const { p1, p2 } = closestSegment;
          const timeDiffSeconds = p2.timestamp - p1.timestamp;
          const distanceMeters = calculateDistance(p1.latitude, p1.longitude, p2.latitude, p2.longitude);

          // Update highlighted segment layer
          if (map.getSource('highlighted-segment')) {
            map.getSource('highlighted-segment').setData({
              type: 'Feature',
              geometry: {
                type: 'LineString',
                coordinates: [
                  [p1.longitude, p1.latitude, p1.altitude],
                  [p2.longitude, p2.latitude, p2.altitude]
                ]
              },
              properties: {}
            });
          }

          let speedKmphText = "---";
          if (timeDiffSeconds > 0) {
            const speedKmph = (distanceMeters / 1000) / (timeDiffSeconds / 3600);
            speedKmphText = `${speedKmph.toFixed(2)} km/h`;
          } else if (timeDiffSeconds === 0) {
            if (distanceMeters > 0) {
              speedKmphText = "瞬时移动"; // Instantaneous movement
            } else {
              speedKmphText = "0.00 km/h (静止)"; // Stationary
            }
          } else { // timeDiffSeconds < 0, should ideally not happen if points are sorted
            speedKmphText = "数据错误"; // Data error (e.g., time reversed)
          }

          const segmentStartTime = new Date(p1.timestamp * 1000).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: false });
          const segmentEndTime = new Date(p2.timestamp * 1000).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: false });
          const segmentDuration = Math.abs(timeDiffSeconds);

          const popupContent = `
            <div style="font-family: sans-serif; font-size: 0.9em; line-height: 1.4;">
              <strong>轨迹段信息</strong><br>
              时段: ${segmentStartTime} - ${segmentEndTime}<br>
              时长: ${segmentDuration.toFixed(1)} 秒<br>
              距离: ${distanceMeters.toFixed(1)} 米<br>
              速度: ${speedKmphText}
            </div>
          `;

          trackPopup
            .setLngLat(mouseLngLat) // Position popup at the mouse cursor
            .setHTML(popupContent)
            .addTo(map);
        } else {
          if (trackPopup.isOpen()) trackPopup.remove();
          // Clear highlighted segment if no segment is closest
          if (map.getSource('highlighted-segment')) {
            map.getSource('highlighted-segment').setData({
              type: 'Feature', geometry: { type: 'LineString', coordinates: [] }, properties: {}
            });
          }
        }
      });

      map.on('mouseleave', 'full-track-line', function () {
        if (trackPopup.isOpen()) trackPopup.remove();
        map.getCanvas().style.cursor = '';
        // Clear highlighted segment layer
        if (map.getSource('highlighted-segment')) {
          map.getSource('highlighted-segment').setData({
            type: 'Feature', geometry: { type: 'LineString', coordinates: [] }, properties: {}
          });
        }
      });

    });

    slider.addEventListener('input', (e) => {
      const index = parseInt(e.target.value);
      updateMapForIndex(index);
    });

    map.on('error', (e) => {
      console.error('MapLibre GL JS Error:', e);
      if (e.error && e.error.status === 403 && e.url && e.url.includes('openfreemap.org')) {
        alert("无法加载 OpenFreeMap 瓦片。请检查网络连接或瓦片服务状态。");
      } else if (e.error) {
        alert("加载地图时出错: " + (e.error.message || "未知错误"));
      }
    });
  </script>
</body>

</html>
