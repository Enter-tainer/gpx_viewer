<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8" />
  <title>GPX 轨迹可视化 (拖放加载) - 带方向箭头</title>
  <meta name="viewport" content="initial-scale=1,maximum-scale=1,user-scalable=no" />
  <link href="https://unpkg.com/maplibre-gl@4.1.0/dist/maplibre-gl.css" rel="stylesheet" />
  <style>
    body {
      margin: 0;
      padding: 0;
    }

    #map {
      position: absolute;
      top: 0;
      bottom: 0;
      width: 100%;
      background-color: #f0f0f0;
      /* Default background for map area */
    }

    .controls {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(255, 255, 255, 0.9);
      /* Slightly more opaque */
      padding: 10px 20px;
      border-radius: 8px;
      /* Softer corners */
      z-index: 1;
      display: flex;
      align-items: center;
      gap: 15px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      /* Enhanced shadow */
    }

    .controls label {
      font-family: sans-serif;
      font-size: 14px;
    }

    #timeslider {
      width: 300px;
    }

    #timestamp-display {
      font-family: monospace;
      font-size: 13px;
      min-width: 180px;
      /* 保证足够宽度显示时间 */
      padding: 5px;
      background-color: #f8f9fa;
      border-radius: 4px;
    }

    /* Style for drag-over effect */
    #map.dragover {
      border: 3px dashed #007bff;
      box-shadow: inset 0 0 30px rgba(0, 123, 255, 0.3);
    }

    .drop-prompt {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background-color: rgba(255, 255, 255, 0.95);
      padding: 25px 30px;
      border-radius: 10px;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      /* Modern font */
      font-size: 1.3em;
      color: #333;
      text-align: center;
      z-index: 10;
      pointer-events: auto;
      /* 允许点击交互 */
      display: none;
      /* Hidden by default */
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
      cursor: pointer;
      /* 鼠标悬停时显示指针 */
      transition: background-color 0.2s, transform 0.1s;
      /* 平滑过渡效果 */
    }

    .drop-prompt:hover {
      background-color: rgba(255, 255, 255, 1);
      transform: translate(-50%, -50%) scale(1.02);
      /* 轻微放大效果 */
    }

    .drop-prompt:active {
      transform: translate(-50%, -50%) scale(0.98);
      /* 点击时缩小效果 */
    }

    /* Show prompt when no track is loaded */
    #map.no-track .drop-prompt {
      display: block;
    }

    /* 隐藏文件输入框 */
    #file-input {
      display: none;
    }

    /* 轨迹颜色模式选择控件样式 */
    #color-mode-select {
      font-size: 14px;
      padding: 3px 8px;
      border-radius: 4px;
      border: 1px solid #ccc;
      margin-left: 8px;
    }
  </style>
</head>

<body>

  <div id="map">
    <div class="drop-prompt" id="drop-prompt-message">请拖放 GPX 文件到地图区域<br>或点击此处选择文件</div>
  </div>
  <div class="controls">
    <label for="timeslider">轨迹进度:</label>
    <input type="range" id="timeslider" min="0" value="0" step="1" disabled />
    <div id="timestamp-display">未加载数据</div>
    <label for="color-mode-select" style="margin-left:16px;">轨迹颜色:</label>
    <select id="color-mode-select">
      <option value="fixed">固定颜色</option>
      <option value="speed">速度模式</option>
      <option value="time">时间模式</option>
    </select>
  </div>
  <input type="file" id="file-input" accept=".gpx" />

  <script src="https://unpkg.com/maplibre-gl@4.1.0/dist/maplibre-gl.js"></script>
  <script>
    let map;
    let currentPoints = [];
    let currentFullTrackGeoJSON = { type: 'Feature', geometry: { type: 'LineString', coordinates: [] }, properties: {} };

    const slider = document.getElementById('timeslider');
    const timestampDisplay = document.getElementById('timestamp-display');
    const mapContainer = document.getElementById('map');
    const dropPromptMessage = document.getElementById('drop-prompt-message');
    const fileInput = document.getElementById('file-input');
    let currentColorMode = 'fixed';
    const colorModeSelect = document.getElementById('color-mode-select');
    colorModeSelect.addEventListener('change', function () {
      currentColorMode = colorModeSelect.value;
      updateTrackSegmentsLayer();
    });

    dropPromptMessage.addEventListener('click', () => fileInput.click());
    fileInput.addEventListener('change', (event) => {
      if (event.target.files && event.target.files.length > 0) {
        processSelectedFile(event.target.files[0]);
      }
    });

    function processSelectedFile(file) {
      if (file.name.toLowerCase().endsWith('.gpx')) {
        dropPromptMessage.textContent = "正在处理 GPX 文件...";
        const reader = new FileReader();
        reader.onload = (e) => {
          try {
            const gpxString = e.target.result;
            const newRawData = parseGPXToRawTrackData(gpxString);
            if (newRawData !== null) {
              loadTrackDataOnMap(newRawData);
            } else {
              timestampDisplay.textContent = "GPX 解析失败";
              slider.disabled = true;
              mapContainer.classList.add('no-track');
              dropPromptMessage.textContent = "GPX 解析失败，请检查文件并重试\n或点击此处选择另一个文件";
            }
          } catch (error) {
            console.error("处理 GPX 文件时出错:", error);
            alert("处理 GPX 文件时发生意外错误: " + error.message);
            timestampDisplay.textContent = "GPX 加载异常";
            slider.disabled = true;
            mapContainer.classList.add('no-track');
            dropPromptMessage.textContent = "GPX 加载异常，请重试\n或点击此处选择另一个文件";
          }
        };
        reader.onerror = (e) => {
          console.error("读取文件失败:", e);
          alert("读取文件失败。请检查浏览器权限或文件本身。");
          timestampDisplay.textContent = "文件读取错误";
          slider.disabled = true;
          mapContainer.classList.add('no-track');
          dropPromptMessage.textContent = "文件读取错误，请重试\n或点击此处选择另一个文件";
        };
        reader.readAsText(file);
      } else {
        alert("请选择一个 .gpx 文件。");
        dropPromptMessage.textContent = "非 GPX 文件，请选择或拖放 .gpx 文件";
        setTimeout(() => {
          if (currentPoints.length === 0) dropPromptMessage.textContent = "请拖放 GPX 文件到地图区域\n或点击此处选择文件";
        }, 2000);
      }
      fileInput.value = '';
    }

    function processTrackData(rawData) {
      if (!rawData || rawData.length === 0) {
        return {
          points: [],
          fullTrackGeoJSON: { type: 'Feature', geometry: { type: 'LineString', coordinates: [] }, properties: {} }
        };
      }
      const sortedRawData = rawData.sort((a, b) => a.timestamp - b.timestamp);
      const points = sortedRawData.map(p => ({
        longitude: p.longitude_scaled_1e5 / 1e5,
        latitude: p.latitude_scaled_1e5 / 1e5,
        altitude: p.altitude_m_scaled_1e1 / 1e1,
        timestamp: p.timestamp
      }));
      const coordinates = points.map(p => [p.longitude, p.latitude, p.altitude]);
      return {
        points: points,
        fullTrackGeoJSON: {
          type: 'Feature',
          geometry: { type: 'LineString', coordinates: coordinates },
          properties: {}
        }
      };
    }

    function parseGPXToRawTrackData(gpxString) {
      const parser = new DOMParser();
      const xmlDoc = parser.parseFromString(gpxString, "text/xml");
      const newRawData = [];
      const parseError = xmlDoc.getElementsByTagName("parsererror");
      if (parseError.length > 0) {
        console.error("GPX parsing error:", parseError[0].textContent);
        alert("GPX 文件解析失败。请检查文件格式。\n错误详情: " + parseError[0].textContent);
        return null;
      }
      const trkpts = xmlDoc.querySelectorAll('trkpt');
      if (trkpts.length === 0) {
        console.warn("GPX 文件中未找到 <trkpt> 元素。");
        alert("GPX 文件中未找到有效的轨迹点 (<trkpt>)。");
        return [];
      }
      trkpts.forEach((trkpt, index) => {
        const latAttr = trkpt.getAttribute('lat');
        const lonAttr = trkpt.getAttribute('lon');
        if (!latAttr || !lonAttr) {
          console.warn(`Trackpoint ${index + 1} 缺少经纬度属性，将被跳过。`);
          return;
        }
        const lat = parseFloat(latAttr);
        const lon = parseFloat(lonAttr);
        let ele = 0;
        const eleTag = trkpt.querySelector('ele');
        if (eleTag && eleTag.textContent) ele = parseFloat(eleTag.textContent);
        let time = null;
        const timeTag = trkpt.querySelector('time');
        if (timeTag && timeTag.textContent) {
          time = Math.floor(new Date(timeTag.textContent).getTime() / 1000);
        } else {
          console.warn(`Trackpoint ${index + 1} (Lat: ${lat}, Lon: ${lon}) 缺少时间信息，将被跳过。`);
          return;
        }
        if (!isNaN(lat) && !isNaN(lon) && time !== null && !isNaN(time)) {
          newRawData.push({
            timestamp: time,
            latitude_scaled_1e5: Math.round(lat * 1e5),
            longitude_scaled_1e5: Math.round(lon * 1e5),
            altitude_m_scaled_1e1: Math.round(ele * 1e1)
          });
        } else {
          console.warn(`跳过无效的轨迹点数据: Lat=${lat}, Lon=${lon}, Time=${time}, Ele=${ele}`);
        }
      });
      if (newRawData.length === 0 && trkpts.length > 0) {
        alert("GPX 文件中的轨迹点均无效或缺少必要信息 (有效的经纬度、时间)。");
      }
      return newRawData;
    }

    function updateMapForIndex(index) {
      if (!map.loaded() || !map.getSource('current-point') || !map.getSource('travelled-track')) {
        console.warn("Map or sources not ready for updateMapForIndex");
        return;
      }
      if (!currentPoints || currentPoints.length === 0 || index < 0 || index >= currentPoints.length) {
        if (currentPoints && currentPoints.length === 0) {
          timestampDisplay.textContent = "无轨迹数据";
          map.getSource('current-point').setData({ type: 'FeatureCollection', features: [] });
          map.getSource('travelled-track').setData({ type: 'Feature', geometry: { type: 'LineString', coordinates: [] }, properties: {} });
        }
        return;
      }
      const currentPointData = currentPoints[index];
      map.getSource('current-point').setData({
        type: 'Feature',
        geometry: { type: 'Point', coordinates: [currentPointData.longitude, currentPointData.latitude] },
        properties: { timestamp: currentPointData.timestamp, altitude: currentPointData.altitude }
      });
      const travelledCoordinates = currentPoints.slice(0, index + 1).map(p => [p.longitude, p.latitude, p.altitude]);
      map.getSource('travelled-track').setData({
        type: 'Feature',
        geometry: { type: 'LineString', coordinates: travelledCoordinates },
        properties: {}
      });
      const date = new Date(currentPointData.timestamp * 1000);
      timestampDisplay.textContent = `${date.toLocaleString()} (海拔: ${currentPointData.altitude.toFixed(1)}m)`;
    }

    // NEW: Function to calculate bearing between two points
    function calculateBearing(lat1, lon1, lat2, lon2) {
      const toRadians = Math.PI / 180;
      const toDegrees = 180 / Math.PI;

      const y = Math.sin((lon2 - lon1) * toRadians) * Math.cos(lat2 * toRadians);
      const x = Math.cos(lat1 * toRadians) * Math.sin(lat2 * toRadians) -
        Math.sin(lat1 * toRadians) * Math.cos(lat2 * toRadians) * Math.cos((lon2 - lon1) * toRadians);
      let brng = Math.atan2(y, x) * toDegrees;
      brng = (brng + 360) % 360; // Normalize to 0-360
      return brng;
    }

    // Helper function to calculate distance between two lat/lon points (Haversine formula)
    function calculateDistance(lat1, lon1, lat2, lon2) {
      const R = 6371e3; // Earth radius in meters
      const phi1 = lat1 * Math.PI / 180;
      const phi2 = lat2 * Math.PI / 180;
      const deltaPhi = (lat2 - lat1) * Math.PI / 180;
      const deltaLambda = (lon2 - lon1) * Math.PI / 180;

      const a = Math.sin(deltaPhi / 2) * Math.sin(deltaPhi / 2) +
        Math.cos(phi1) * Math.cos(phi2) *
        Math.sin(deltaLambda / 2) * Math.sin(deltaLambda / 2);
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

      return R * c; // Distance in meters
    }

    // 箭头密度控制相关常量
    const BASE_ARROW_ZOOM = 15; // 以15级为基准
    const ARROW_INTERVAL_METERS_AT_BASE_ZOOM = 250; // 15级时250米一个箭头
    const MIN_ARROW_INTERVAL_METERS = 30; // 最小30米
    const MAX_ARROW_INTERVAL_METERS = 2000000; // 最大2公里

    // 动态生成箭头，传入当前zoom
    function generateArrowFeatures(trackPoints, currentZoom) {
      const features = [];
      if (!trackPoints || trackPoints.length < 2) {
        return { type: 'FeatureCollection', features: features };
      }
      // 动态计算当前缩放下的地理间距
      let arrowIntervalMeters = ARROW_INTERVAL_METERS_AT_BASE_ZOOM * Math.pow(2, BASE_ARROW_ZOOM - currentZoom);
      arrowIntervalMeters = Math.max(MIN_ARROW_INTERVAL_METERS, Math.min(MAX_ARROW_INTERVAL_METERS, arrowIntervalMeters));

      let distanceSinceLastArrow = 0;
      let bearing = calculateBearing(trackPoints[0].latitude, trackPoints[0].longitude, trackPoints[1].latitude, trackPoints[1].longitude);
      features.push({
        type: 'Feature',
        geometry: { type: 'Point', coordinates: [trackPoints[0].longitude, trackPoints[0].latitude] },
        properties: { bearing }
      });
      for (let i = 1; i < trackPoints.length; i++) {
        const p1 = trackPoints[i - 1];
        const p2 = trackPoints[i];
        if (p1.longitude === p2.longitude && p1.latitude === p2.latitude) continue;
        const segmentDistance = calculateDistance(p1.latitude, p1.longitude, p2.latitude, p2.longitude);
        const totalDistance = distanceSinceLastArrow + segmentDistance;
        if (totalDistance >= arrowIntervalMeters) {
          const arrowCount = Math.floor(totalDistance / arrowIntervalMeters);
          for (let j = 1; j <= arrowCount; j++) {
            const d = arrowIntervalMeters * j - distanceSinceLastArrow;
            const t = d / segmentDistance;
            const lat = p1.latitude + (p2.latitude - p1.latitude) * t;
            const lon = p1.longitude + (p2.longitude - p1.longitude) * t;
            const bearing = calculateBearing(p1.latitude, p1.longitude, p2.latitude, p2.longitude);
            features.push({
              type: 'Feature',
              geometry: { type: 'Point', coordinates: [lon, lat] },
              properties: { bearing }
            });
          }
          distanceSinceLastArrow = totalDistance % arrowIntervalMeters;
        } else {
          distanceSinceLastArrow = totalDistance;
        }
      }
      return { type: 'FeatureCollection', features: features };
    }

    // 生成分段轨迹GeoJSON，按colorMode着色
    function generateSegmentedTrackGeoJSON(points, colorMode) {
      if (!points || points.length < 2) return { type: 'FeatureCollection', features: [] };
      const features = [];
      if (colorMode === 'fixed') {
        for (let i = 0; i < points.length - 1; i++) {
          const p1 = points[i], p2 = points[i + 1];
          features.push({
            type: 'Feature',
            geometry: { type: 'LineString', coordinates: [[p1.longitude, p1.latitude, p1.altitude], [p2.longitude, p2.latitude, p2.altitude]] },
            properties: { color: '#007bff' }
          });
        }
      } else if (colorMode === 'speed') {
        // 计算每段速度，找最大最小
        let minV = Infinity, maxV = -Infinity;
        const speeds = [];
        for (let i = 0; i < points.length - 1; i++) {
          const p1 = points[i], p2 = points[i + 1];
          const dt = p2.timestamp - p1.timestamp;
          const dist = calculateDistance(p1.latitude, p1.longitude, p2.latitude, p2.longitude);
          let v = (dt > 0) ? (dist / dt) : 0; // m/s
          speeds.push(v);
          if (v < minV) minV = v;
          if (v > maxV) maxV = v;
        }
        // 归一化并着色
        for (let i = 0; i < points.length - 1; i++) {
          const p1 = points[i], p2 = points[i + 1];
          let norm = (maxV > minV) ? (speeds[i] - minV) / (maxV - minV) : 0;
          features.push({
            type: 'Feature',
            geometry: { type: 'LineString', coordinates: [[p1.longitude, p1.latitude, p1.altitude], [p2.longitude, p2.latitude, p2.altitude]] },
            properties: { color: turboColormap(norm) }
          });
        }
      } else if (colorMode === 'time') {
        // 计算全局时间区间
        const t0 = points[0].timestamp, t1 = points[points.length - 1].timestamp;
        for (let i = 0; i < points.length - 1; i++) {
          const p1 = points[i], p2 = points[i + 1];
          let norm = (t1 > t0) ? (p1.timestamp - t0) / (t1 - t0) : 0;
          features.push({
            type: 'Feature',
            geometry: { type: 'LineString', coordinates: [[p1.longitude, p1.latitude, p1.altitude], [p2.longitude, p2.latitude, p2.altitude]] },
            properties: { color: turboColormap(norm) }
          });
        }
      }
      return { type: 'FeatureCollection', features };
    }

    function loadTrackDataOnMap(newRawTrackData) {
      const processed = processTrackData(newRawTrackData);
      currentPoints = processed.points;
      currentFullTrackGeoJSON = processed.fullTrackGeoJSON;

      if (currentPoints.length === 0) {
        timestampDisplay.textContent = "GPX 文件无有效轨迹数据";
        slider.disabled = true;
        slider.value = 0;
        slider.max = 0;
        mapContainer.classList.add('no-track');
        dropPromptMessage.textContent = "GPX 无有效数据或解析失败，请重试\n或点击此处选择另一个文件";
        if (map.getSource('full-track')) {
          map.getSource('full-track').setData({ type: 'Feature', geometry: { type: 'LineString', coordinates: [] }, properties: {} });
        }
        if (map.getSource('arrow-points')) {
          map.getSource('arrow-points').setData({ type: 'FeatureCollection', features: [] });
        }
        if (map.getSource('track-segments')) {
          map.getSource('track-segments').setData({ type: 'FeatureCollection', features: [] });
        }
        updateMapForIndex(0);
        return;
      }

      mapContainer.classList.remove('no-track');
      slider.max = currentPoints.length - 1;
      slider.value = 0;
      slider.disabled = false;

      map.getSource('full-track').setData(currentFullTrackGeoJSON);
      updateMapForIndex(0);
      if (map.getSource('arrow-points') && map.style.getImage('arrow-icon')) {
        const arrowFeatures = generateArrowFeatures(currentPoints, map.getZoom());
        map.getSource('arrow-points').setData(arrowFeatures);
      } else if (map.getSource('arrow-points')) {
        setTimeout(() => {
          if (map.getSource('arrow-points') && map.style.getImage('arrow-icon')) {
            const arrowFeatures = generateArrowFeatures(currentPoints, map.getZoom());
            map.getSource('arrow-points').setData(arrowFeatures);
          }
        }, 500);
      }
      if (map.getSource('track-segments')) {
        updateTrackSegmentsLayer();
      }
      if (currentFullTrackGeoJSON.geometry.coordinates.length > 1) {
        const bounds = new maplibregl.LngLatBounds();
        currentFullTrackGeoJSON.geometry.coordinates.forEach(coord => {
          bounds.extend(coord.slice(0, 2));
        });
        map.fitBounds(bounds, { padding: 60 });
      }
    }

    function handleFileDrop(event) {
      event.preventDefault();
      event.stopPropagation();
      mapContainer.classList.remove('dragover');
      dropPromptMessage.textContent = "正在处理 GPX 文件...";
      if (event.dataTransfer.files && event.dataTransfer.files.length > 0) {
        processSelectedFile(event.dataTransfer.files[0]);
      } else {
        if (currentPoints.length === 0) dropPromptMessage.textContent = "请拖放 GPX 文件到地图区域\n或点击此处选择文件";
      }
    }

    function handleDragOver(event) {
      event.preventDefault();
      event.stopPropagation();
      mapContainer.classList.add('dragover');
      dropPromptMessage.textContent = "松开以加载 GPX 文件";
    }

    function handleDragLeave(event) {
      event.preventDefault();
      event.stopPropagation();
      mapContainer.classList.remove('dragover');
      if (currentPoints.length === 0) {
        dropPromptMessage.textContent = "请拖放 GPX 文件到地图区域\n或点击此处选择文件";
      }
    }

    map = new maplibregl.Map({
      container: 'map',
      style: 'https://tiles.openfreemap.org/styles/liberty',
      center: [139.767, 35.681],
      zoom: 5
    });

    map.on('load', () => {
      mapContainer.classList.add('no-track');

      map.addSource('full-track', {
        type: 'geojson',
        data: currentFullTrackGeoJSON
      });
      map.addLayer({
        id: 'full-track-line',
        type: 'line',
        source: 'full-track',
        layout: { 'line-join': 'round', 'line-cap': 'round' },
        paint: { 'line-color': '#007bff', 'line-width': 5, 'line-opacity': 0.8 }
      });

      // Add source and layer for the highlighted segment
      map.addSource('highlighted-segment', {
        type: 'geojson',
        data: { type: 'Feature', geometry: { type: 'LineString', coordinates: [] }, properties: {} }
      });
      map.addLayer({
        id: 'highlighted-segment-line',
        type: 'line',
        source: 'highlighted-segment',
        layout: { 'line-join': 'round', 'line-cap': 'round' },
        paint: {
          'line-color': '#FFD700', // Gold color for highlight
          'line-width': 7,         // Slightly wider
          'line-opacity': 0.85
        }
      }); // This layer will be on top of 'full-track-line' by default

      // NEW: Add SVG arrow image to map's style
      const arrowUpSvgString = `<svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 12 12"><polygon points="6,0 12,9 0,9" fill="currentColor"/></svg>`;


      const img = new Image(16, 16); // Should match SVG width/height for consistency, or let browser decide.
      img.onload = () => {
        map.addImage('arrow-icon', img, { sdf: true }); // sdf: true allows recoloring

        // NEW: Add source for arrow points (initially empty)
        map.addSource('arrow-points', {
          type: 'geojson',
          data: { type: 'FeatureCollection', features: [] }
        });

        // NEW: Add layer for arrows, below the travelled track and current point for clarity
        map.addLayer({
          id: 'gpx-arrows',
          type: 'symbol',
          source: 'arrow-points',
          layout: {
            'icon-image': 'arrow-icon',
            'icon-size': 0.7, // Adjust size as needed
            'icon-rotate': ['get', 'bearing'],
            'icon-rotation-alignment': 'map',
            'icon-allow-overlap': true,
            'icon-ignore-placement': true // Important to show all arrows
          },
          paint: {
            'icon-color': '#003399', // Dark blue, or choose another color
            'icon-opacity': 0.85
          }
        }, 'travelled-track-line'); // Place arrows below travelled track, adjust if needed
      };
      img.onerror = (e) => {
        console.error("Failed to load arrow SVG for map icon.", e);
        alert("无法加载箭头图标，轨迹方向将不显示。");
      };
      // Using a triangle pointing "up" (in its local SVG coordinate space, Y decreases upwards).
      // For a map icon that should point "north" at 0 degrees rotation, this means pointing to top of SVG.
      img.src = 'data:image/svg+xml;base64,' + btoa(arrowUpSvgString);


      map.addSource('travelled-track', {
        type: 'geojson',
        data: { type: 'Feature', geometry: { type: 'LineString', coordinates: [] }, properties: {} }
      });
      map.addLayer({
        id: 'travelled-track-line',
        type: 'line',
        source: 'travelled-track',
        layout: { 'line-join': 'round', 'line-cap': 'round' },
        paint: { 'line-color': '#28a745', 'line-width': 6, 'line-opacity': 0.9 }
      });

      map.addSource('current-point', {
        type: 'geojson',
        data: { type: 'FeatureCollection', features: [] }
      });
      map.addLayer({
        id: 'current-point-marker',
        type: 'circle',
        source: 'current-point',
        paint: {
          'circle-radius': 8, 'circle-color': '#dc3545',
          'circle-stroke-width': 2, 'circle-stroke-color': '#ffffff'
        }
      });

      // 新增分段轨迹source和layer
      map.addSource('track-segments', {
        type: 'geojson',
        data: { type: 'FeatureCollection', features: [] }
      });
      map.addLayer({
        id: 'track-segments-line',
        type: 'line',
        source: 'track-segments',
        layout: { 'line-join': 'round', 'line-cap': 'round' },
        paint: {
          'line-color': ['get', 'color'],
          'line-width': 5,
          'line-opacity': 0.95
        }
      }, 'full-track-line'); // 保证在主轨迹线之上

      // 初始化时隐藏分段轨迹图层
      map.setLayoutProperty('track-segments-line', 'visibility', 'none');

      mapContainer.addEventListener('dragover', handleDragOver);
      mapContainer.addEventListener('dragleave', handleDragLeave);
      mapContainer.addEventListener('drop', handleFileDrop);

      timestampDisplay.textContent = "请拖放 GPX 文件";
      slider.disabled = true;
      slider.value = 0;
      slider.max = 0;

      // NEW: Popup for track segment information
      let trackPopup = new maplibregl.Popup({
        closeButton: false,
        closeOnClick: false,
        offset: 15 // Offset the popup slightly from the cursor
      });

      map.on('mousemove', 'full-track-line', function (e) {
        if (!currentPoints || currentPoints.length < 2) {
          if (trackPopup.isOpen()) trackPopup.remove();
          map.getCanvas().style.cursor = '';
          return;
        }
        map.getCanvas().style.cursor = 'pointer';

        const mouseLngLat = e.lngLat;
        let closestSegment = null;
        let minDistanceSqToMidpoint = Infinity; // Using squared distance to avoid sqrt

        for (let i = 0; i < currentPoints.length - 1; i++) {
          const p1 = currentPoints[i];
          const p2 = currentPoints[i + 1];

          // Ensure p1 and p2 are valid points with longitude and latitude
          if (!p1 || !p2 || typeof p1.longitude !== 'number' || typeof p1.latitude !== 'number' ||
            typeof p2.longitude !== 'number' || typeof p2.latitude !== 'number') {
            console.warn('Skipping invalid segment due to missing coordinates:', p1, p2);
            continue;
          }

          const midLng = (p1.longitude + p2.longitude) / 2;
          const midLat = (p1.latitude + p2.latitude) / 2;

          // Approximate distance squared (faster than sqrt) from mouse to segment midpoint
          const distLat = midLat - mouseLngLat.lat;
          const distLng = midLng - mouseLngLat.lng;
          const distanceSq = distLat * distLat + distLng * distLng;

          if (distanceSq < minDistanceSqToMidpoint) {
            minDistanceSqToMidpoint = distanceSq;
            closestSegment = { p1, p2, index: i };
          }
        }

        if (closestSegment) {
          const { p1, p2 } = closestSegment;
          const timeDiffSeconds = p2.timestamp - p1.timestamp;
          const distanceMeters = calculateDistance(p1.latitude, p1.longitude, p2.latitude, p2.longitude);

          // Update highlighted segment layer
          if (map.getSource('highlighted-segment')) {
            map.getSource('highlighted-segment').setData({
              type: 'Feature',
              geometry: {
                type: 'LineString',
                coordinates: [
                  [p1.longitude, p1.latitude, p1.altitude],
                  [p2.longitude, p2.latitude, p2.altitude]
                ]
              },
              properties: {}
            });
          }

          let speedKmphText = "---";
          if (timeDiffSeconds > 0) {
            const speedKmph = (distanceMeters / 1000) / (timeDiffSeconds / 3600);
            speedKmphText = `${speedKmph.toFixed(2)} km/h`;
          } else if (timeDiffSeconds === 0) {
            if (distanceMeters > 0) {
              speedKmphText = "瞬时移动"; // Instantaneous movement
            } else {
              speedKmphText = "0.00 km/h (静止)"; // Stationary
            }
          } else { // timeDiffSeconds < 0, should ideally not happen if points are sorted
            speedKmphText = "数据错误"; // Data error (e.g., time reversed)
          }

          const segmentStartTime = new Date(p1.timestamp * 1000).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: false });
          const segmentEndTime = new Date(p2.timestamp * 1000).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: false });
          const segmentDuration = Math.abs(timeDiffSeconds);

          const popupContent = `
            <div style="font-family: sans-serif; font-size: 0.9em; line-height: 1.4;">
              <strong>轨迹段信息</strong><br>
              时段: ${segmentStartTime} - ${segmentEndTime}<br>
              时长: ${segmentDuration.toFixed(1)} 秒<br>
              距离: ${distanceMeters.toFixed(1)} 米<br>
              速度: ${speedKmphText}
            </div>
          `;

          trackPopup
            .setLngLat(mouseLngLat) // Position popup at the mouse cursor
            .setHTML(popupContent)
            .addTo(map);
        } else {
          if (trackPopup.isOpen()) trackPopup.remove();
          // Clear highlighted segment if no segment is closest
          if (map.getSource('highlighted-segment')) {
            map.getSource('highlighted-segment').setData({
              type: 'Feature', geometry: { type: 'LineString', coordinates: [] }, properties: {}
            });
          }
        }
      });

      // 绑定hover事件到分段轨迹图层
      function handleTrackHoverLayer(layerId) {
        map.on('mousemove', layerId, function (e) {
          if (!currentPoints || currentPoints.length < 2) {
            if (trackPopup.isOpen()) trackPopup.remove();
            map.getCanvas().style.cursor = '';
            return;
          }
          map.getCanvas().style.cursor = 'pointer';

          const mouseLngLat = e.lngLat;
          let closestSegment = null;
          let minDistanceSqToMidpoint = Infinity;

          for (let i = 0; i < currentPoints.length - 1; i++) {
            const p1 = currentPoints[i];
            const p2 = currentPoints[i + 1];
            if (!p1 || !p2 || typeof p1.longitude !== 'number' || typeof p1.latitude !== 'number' ||
              typeof p2.longitude !== 'number' || typeof p2.latitude !== 'number') {
              continue;
            }
            const midLng = (p1.longitude + p2.longitude) / 2;
            const midLat = (p1.latitude + p2.latitude) / 2;
            const distLat = midLat - mouseLngLat.lat;
            const distLng = midLng - mouseLngLat.lng;
            const distanceSq = distLat * distLat + distLng * distLng;
            if (distanceSq < minDistanceSqToMidpoint) {
              minDistanceSqToMidpoint = distanceSq;
              closestSegment = { p1, p2, index: i };
            }
          }

          if (closestSegment) {
            const { p1, p2 } = closestSegment;
            const timeDiffSeconds = p2.timestamp - p1.timestamp;
            const distanceMeters = calculateDistance(p1.latitude, p1.longitude, p2.latitude, p2.longitude);
            if (map.getSource('highlighted-segment')) {
              map.getSource('highlighted-segment').setData({
                type: 'Feature',
                geometry: {
                  type: 'LineString',
                  coordinates: [
                    [p1.longitude, p1.latitude, p1.altitude],
                    [p2.longitude, p2.latitude, p2.altitude]
                  ]
                },
                properties: {}
              });
            }
            let speedKmphText = "---";
            if (timeDiffSeconds > 0) {
              const speedKmph = (distanceMeters / 1000) / (timeDiffSeconds / 3600);
              speedKmphText = `${speedKmph.toFixed(2)} km/h`;
            } else if (timeDiffSeconds === 0) {
              if (distanceMeters > 0) {
                speedKmphText = "瞬时移动";
              } else {
                speedKmphText = "0.00 km/h (静止)";
              }
            } else {
              speedKmphText = "数据错误";
            }
            const segmentStartTime = new Date(p1.timestamp * 1000).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: false });
            const segmentEndTime = new Date(p2.timestamp * 1000).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: false });
            const segmentDuration = Math.abs(timeDiffSeconds);
            const popupContent = `
              <div style="font-family: sans-serif; font-size: 0.9em; line-height: 1.4;">
                <strong>轨迹段信息</strong><br>
                时段: ${segmentStartTime} - ${segmentEndTime}<br>
                时长: ${segmentDuration.toFixed(1)} 秒<br>
                距离: ${distanceMeters.toFixed(1)} 米<br>
                速度: ${speedKmphText}
              </div>
            `;
            trackPopup
              .setLngLat(mouseLngLat)
              .setHTML(popupContent)
              .addTo(map);
          } else {
            if (trackPopup.isOpen()) trackPopup.remove();
            if (map.getSource('highlighted-segment')) {
              map.getSource('highlighted-segment').setData({
                type: 'Feature', geometry: { type: 'LineString', coordinates: [] }, properties: {}
              });
            }
          }
        });
        map.on('mouseleave', layerId, function () {
          if (trackPopup.isOpen()) trackPopup.remove();
          map.getCanvas().style.cursor = '';
          if (map.getSource('highlighted-segment')) {
            map.getSource('highlighted-segment').setData({
              type: 'Feature', geometry: { type: 'LineString', coordinates: [] }, properties: {}
            });
          }
        });
      }
      handleTrackHoverLayer('full-track-line');
      handleTrackHoverLayer('track-segments-line');

    });

    slider.addEventListener('input', (e) => {
      const index = parseInt(e.target.value);
      updateMapForIndex(index);
    });

    map.on('error', (e) => {
      console.error('MapLibre GL JS Error:', e);
      if (e.error && e.error.status === 403 && e.url && e.url.includes('openfreemap.org')) {
        alert("无法加载 OpenFreeMap 瓦片。请检查网络连接或瓦片服务状态。");
      } else if (e.error) {
        alert("加载地图时出错: " + (e.error.message || "未知错误"));
      }
    });

    // 地图缩放后重新生成箭头
    map.on('zoomend', function () {
      if (currentPoints && currentPoints.length > 1 && map.getSource('arrow-points')) {
        const arrowFeatures = generateArrowFeatures(currentPoints, map.getZoom());
        map.getSource('arrow-points').setData(arrowFeatures);
      }
    });

    function updateTrackSegmentsLayer() {
      if (!map || !map.getSource('track-segments')) return;
      const segGeoJSON = generateSegmentedTrackGeoJSON(currentPoints, currentColorMode);
      map.getSource('track-segments').setData(segGeoJSON);
      // 控制主线显示/隐藏
      const showFull = currentColorMode === 'fixed';
      map.setLayoutProperty('full-track-line', 'visibility', showFull ? 'visible' : 'none');
      map.setLayoutProperty('track-segments-line', 'visibility', showFull ? 'none' : 'visible');
    }

    function updateTrackColorMode(mode) {
      if (mode === 'fixed') {
        // 固定颜色模式
        map.setPaintProperty('full-track-line', 'line-color', '#007bff');
        map.setPaintProperty('travelled-track-line', 'line-color', '#28a745');
      } else if (mode === 'speed') {
        // 速度模式
        map.setPaintProperty('full-track-line', 'line-color', [
          'interpolate',
          ['linear'],
          ['get', 'average_speed'],
          0, '#00ff00',   // 0 speed: green
          10, '#ffff00',  // 10 units: yellow
          20, '#ff7f00',  // 20 units: orange
          30, '#ff0000'   // 30+ units: red
        ]);
        map.setPaintProperty('travelled-track-line', 'line-color', [
          'interpolate',
          ['linear'],
          ['get', 'average_speed'],
          0, '#00ff00',   // 0 speed: green
          10, '#ffff00',  // 10 units: yellow
          20, '#ff7f00',  // 20 units: orange
          30, '#ff0000'   // 30+ units: red
        ]);
      } else if (mode === 'time') {
        // 时间模式
        map.setPaintProperty('full-track-line', 'line-color', [
          'interpolate',
          ['linear'],
          ['get', 'timestamp'],
          0, '#007bff',   // 最早时间: 蓝色
          1622505600, '#00ff00',  // 中间时间: 绿色
          1625097600, '#ffff00',  // 较晚时间: 黄色
          1627776000, '#ff0000'   // 最晚时间: 红色
        ]);
        map.setPaintProperty('travelled-track-line', 'line-color', [
          'interpolate',
          ['linear'],
          ['get', 'timestamp'],
          0, '#007bff',   // 最早时间: 蓝色
          1622505600, '#00ff00',  // 中间时间: 绿色
          1625097600, '#ffff00',  // 较晚时间: 黄色
          1627776000, '#ff0000'   // 最晚时间: 红色
        ]);
      }
    }

    // turbo colormap: 输入0~1，输出rgb字符串
    function turboColormap(t) {
      // Clamp t to [0,1]
      t = Math.max(0, Math.min(1, t));

      // Polynomial coefficients for Turbo colormap (GLSL version)
      // These are based on the polynomial approximation described by Google.
      const kRedVec4 = [0.13572138, 4.61539260, -42.66032258, 132.13108234];
      const kGreenVec4 = [0.09140261, 2.19418839, 4.84296658, -14.18503333];
      const kBlueVec4 = [0.10667330, 12.64194608, -60.58204836, 110.36276771];
      const kRedVec2 = [-152.94239396, 59.28637943];
      const kGreenVec2 = [4.27729857, 2.82956604];
      const kBlueVec2 = [-89.90310912, 27.34824973];

      // Calculate powers of t
      const t2 = t * t;
      const t3 = t * t2;
      const t4 = t * t3;
      const t5 = t * t4;

      // Calculate the polynomial for each color channel
      const r_float = kRedVec4[0] + kRedVec4[1] * t + kRedVec4[2] * t2 + kRedVec4[3] * t3 + kRedVec2[0] * t4 + kRedVec2[1] * t5;
      const g_float = kGreenVec4[0] + kGreenVec4[1] * t + kGreenVec4[2] * t2 + kGreenVec4[3] * t3 + kGreenVec2[0] * t4 + kGreenVec2[1] * t5;
      const b_float = kBlueVec4[0] + kBlueVec4[1] * t + kBlueVec4[2] * t2 + kBlueVec4[3] * t3 + kBlueVec2[0] * t4 + kBlueVec2[1] * t5;

      // Convert float [0, 1] to integer [0, 255] and round
      const r = Math.round(r_float * 255);
      const g = Math.round(g_float * 255);
      const b = Math.round(b_float * 255);

      return `rgb(${r},${g},${b})`;
    }
  </script>
</body>

</html>
